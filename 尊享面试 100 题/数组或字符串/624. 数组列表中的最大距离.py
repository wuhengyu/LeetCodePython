# -*- coding: utf-8 -*-
# Time    : 2023/5/27 22:30
# Author  : Walter
# File    : 624. 数组列表中的最大距离.py
# License : (C)Copyright Walter
# Version : 1.0
# Desc    :
# 给定m个数组，每个数组都已经按照升序排好序了。现在你需要从两个不同的数组中选择两个整数（每个数组选一个）并且计算它们的距离。
# 两个整数a和b之间的距离定义为它们差的绝对值 | a - b | 。你的任务就是去找到最大距离
#
# 示例
# 1：
# 输入：
# [[1, 2, 3],
#  [4, 5],
#  [1, 2, 3]]
# 输出： 4
# 解释：
# 一种得到答案4的方法是从第一个数组或者第三个数组中选择1，同时从第二个数组中选择5 。
#
# 注意：
# 每个给定数组至少会有1个数字。列表中至少有两个非空数组。所有
# m个数组中的数字总数目在范围[2, 10000]内。
# m个数组中所有整数的范围在[-10000, 10000]内。

'''
在给定的问题中，"最大距离"是指二维整数列表中任意两个子列表之间的最大距离，其中距离定义为两个子列表中的元素之间的距离。
具体来说，对于列表 list[i] 和 list[j]，它们之间的距离可以定义为以下两种情况中的较大值：
|list[i][0] - list[j][k]|，其中 k 是 list[j] 的最后一个元素的下标。
|list[i][k] - list[j][0]|，其中 k 是 list[i] 的最后一个元素的下标。
因此，最大距离是任意两个子列表之间的距离的最大值。您可以将它视为二维数组中两个点之间的曼哈顿距离（Manhattan distance），
其中曼哈顿距离是指从一个点到另一个点沿着网格线（而不是直线）的距离。
'''
from typing import List

# 方法一：枚举 [超出时间限制]
'''
使用两重循环遍历列表中的所有子列表，对于每一对子列表，计算两个距离（即 |list[i][0] - list[j][-1]| 和 |list[j][0] - list[i][-1]|），并将它们与当前的最大距离 res 取最大值。最后，方法返回最大距离 res 的值。
由于输入参数是 [[1, 2, 3], [4, 5], [1, 2, 3]]，因此该方法会遍历所有可能的子列表对，并计算它们之间的距离。具体来说，它首先将 i 设置为 0，j 设置为 1，然后计算子列表 list[0] 和 list[1] 之间的两个距离，即 |1 - 5| 和 |4 - 3|，并将它们与当前的 res 取最大值，更新 res 为 4。
接下来，它将 i 设置为 0，j 设置为 2，然后计算子列表 list[0] 和 list[2] 之间的两个距离，即 |1 - 1| 和 |3 - 3|，这些距离均为 0，因此不会对 res 进行任何更新。
最后，它将 i 设置为 1，j 设置为 2，然后计算子列表 list[1] 和 list[2] 之间的两个距离，即 |4 - 1| 和 |1 - 3|，并将它们与当前的 res 取最大值，更新 res 为 4。因此，函数返回最大距离 res 的值为 4。
'''
'''
对于每一个数组，只有第一个元素（最小的元素）和最后一个元素（最大的元素）是有意义的，因此我们可以枚举选择的两个数组 m[i] 和 m[j]，
随后计算出 m[i] 的第一个元素和 m[j] 的最后一个元素的差的绝对值，以及 m[i] 的最后一个元素和 m[j] 的第一个元素的差的绝对值。
在这些绝对值中，找出最大的距离。
'''


class Solution:
    def maxDistance(self, list: List[List[int]]) -> int:
        res = 0
        for i in range(len(list) - 1):
            for j in range(i + 1, len(list)):
                res = max(res, abs(list[i][0] - list[j][len(list[j]) - 1]))
                res = max(res, abs(list[j][0] - list[i][len(list[i]) - 1]))
        return res


# 方法二：线性扫描
'''
对于给定的二维列表 [[1, 2, 3], [4, 5], [1, 2, 3]]，每个子列表都是已排序的。该问题要求找到两个子列表 list[i] 和 list[j] 之间的最大距离，其中距离定义为 |list[i][0] - list[j][k]| 或 |list[i][k] - list[j][0]|，其中 k 是 list[j] 的最后一个元素的下标。
在给定的代码中，res 变量被初始化为 0，表示当前找到的最大距离。然后，代码通过遍历每对子列表 list[i] 和 list[j] 来更新 res。对于每对子列表，代码计算两个距离，即 |list[i][0] - list[j][k]| 和 |list[i][k] - list[j][0]|，并将它们与当前的 res 取最大值。最后，函数返回 res。
对于输入 [[1, 2, 3], [4, 5], [1, 2, 3]]根据上述算法，程序的具体执行过程如下：
初始化 res 为 0，min_val 为 list[0][0]，max_val 为 list[0][2]。
第一次循环，将 i 设置为 1。
计算 |list[1][2] - min_val| 的值为 |5 - 1| = 4，将其和当前的 res 取最大值，更新 res 为 4。
计算 |max_val - list[1][0]| 的值为 |3 - 4| = 1，将其和当前的 res 取最大值，更新 res 为 4。
将 min_val 更新为 list[1][0]，即 4。
将 max_val 更新为 list[1][1]，即 5。
第二次循环，将 i 设置为 2。
计算 |list[2][2] - min_val| 的值为 |3 - 4| = 1，将其和当前的 res 取最大值，更新res 为 4。
计算 |max_val - list[2][0]| 的值为 |1 - 5| = 4，将其和当前的 res 取最大值，更新 res 为 4。
将 min_val 更新为 list[2][0]，即 1。
将 max_val 更新为 list[2][2]，即 3。
所有循环结束，函数返回 res，即 4。
因此，对于输入 [[1, 2, 3], [4, 5], [1, 2, 3]]，函数 maxDistance 的返回值为 4。
'''
'''
方法一告诉我们，当我们枚举了两个数组之后，只有这两个数组的最小值和最大值才是有意义的。
同理，假设我们确定了第一个数要从第 i 个数组中选择，第二个数要从前 i - 1 个数组中选择，如果我们把前 i - 1 个数组看成一个大的数组，那么只有这 i - 1 个数组中的最小值和最大值才是有意义的。
因此我们找到了可以方法一中可以优化的地方。我们顺序扫描这 m 个数组，当扫描到第 i 个数组时，我们计算出 m[i] 中最小的元素和前 i - 1 个数组中最大的元素 max_val 的差的绝对值，以及 m[i] 中最大的元素和前 i - 1 个数组中最小的元素 min_val 的差的绝对值。
在这之后，我们更新 min_val 和 max_val，使其变为前 i 个数组中最小和最大的元素。
'''


class Solution2:
    def maxDistance(self, list: List[List[int]]) -> int:
        res = 0
        min_val, max_val = list[0][0], list[0][-1]
        for i in range(1, len(list)):
            res = max(res, max(abs(list[i][-1] - min_val), abs(max_val - list[i][0])))
            min_val = min(min_val, list[i][0])
            max_val = max(max_val, list[i][-1])
        return res


print(Solution().maxDistance([[1, 2, 3], [4, 5], [1, 2, 3]]))
print(Solution2().maxDistance([[1, 2, 3], [4, 5], [1, 2, 3]]))
